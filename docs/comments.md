# Inline Comment Anchoring for Markdown Editors

## The Problem

Building a writing editor where Markdown files on disk are the source of truth, but you also need inline comments ‚Äî the ability to select a few words and attach a note to that selection, like Google Docs comments. Unlike Google Docs, which owns its document model end-to-end, Markdown is just a plain text string. There's no built-in concept of annotations, selections, or comment anchors.

This creates a core tension: comments need to be anchored to specific ranges of text, those anchors need to survive edits (both by the user and by AI coding agents), and the system needs to remain compatible with the broader Markdown ecosystem.

### Key Constraints

1. **Markdown on disk**: Files should be openable and editable in any text editor, Obsidian, VS Code, or GitHub's renderer without breaking.
2. **Character-level precision**: Comments should be attachable to a specific phrase or selection, not just a whole paragraph.
3. **Agent-editable**: AI agents (Claude Code, Codex, etc.) should be able to edit the file directly via plain text manipulation.
4. **Agent-readable**: The agent needs to see comment instructions inline so it can act on them without cross-referencing external files.
5. **Ephemeral comments**: Comments are temporary instructions or to-do items, not permanent annotations. They should all eventually be resolved and removed.
6. **Clean rendering**: Comments should not appear in published/rendered output.

## MVP Product Decisions (Current Direction)

These decisions constrain the first implementation pass and should be treated as the source of truth unless replaced by a later design decision.

### Anchoring and Selection Rules (MVP)

- **Allow broad raw-character anchoring for now**: the first pass will not impose extra rules on which characters can be commented on. We will observe real break cases before tightening anchor placement constraints.
- **No nested comments**: a comment range may not contain another comment range.
- **No overlapping comments**: comment ranges may not partially overlap.
- **Selection interaction expectation**: clicking any highlighted text that belongs to a comment should select that comment in the UI.

### Marker Identity and Recovery (MVP)

- **Each comment gets a unique random ID** generated by the app at creation time.
- IDs are an implementation detail (not user-facing), but they exist in the markup so the editor can pair start/end markers and recover from malformed files.
- If orphaned or malformed markers are detected, the editor should prefer safe cleanup/recovery behavior rather than trying to preserve an ambiguous comment.

### Iteration Strategy

- The first pass intentionally prioritizes speed and learning over strict anchor-validation rules.
- We expect to tighten constraints later if raw-character anchoring causes Markdown breakage in real usage.
- When constraints are tightened, the editor should handle older/broken markers defensively.

### Why This Is Hard

How Google Docs solves this (hidden anchor markers managed by an Operational Transformation engine) doesn't apply because Markdown is a plain string, not a proprietary document model. The standard approaches for collaborative editors (OT markers, CRDT character IDs, ProseMirror decorations) all assume the editor owns the document format. When the file is "just Markdown," any comment system has to either live inside the text or beside it ‚Äî and both choices have real costs.

---

## The Options

### Option A: Inline HTML Comments

Embed comment anchors directly in the Markdown body using HTML comment syntax with a predictable naming convention.

```markdown
The real problem with most startups isn't
<!-- @comment:c1 start | "tighten this, too wordy" -->
that founders consistently and repeatedly confuse
motion with progress and activity with achievement
<!-- @comment:c1 end -->
in their day-to-day operations.
```

HTML comments are valid Markdown and are hidden by all standard renderers. The agent sees the instructions right next to the relevant text and can remove them after acting on them.

### Option B: Sidecar File with Content-Based Anchors

Store comments in a companion file (e.g., `essay.comments.json`) using quoted text and surrounding context to locate the anchor range.

```json
{
  "id": "c1",
  "text": "tighten this, too wordy",
  "anchor": {
    "quotation": "that founders consistently and repeatedly confuse motion with progress",
    "prefix": "most startups isn't ",
    "suffix": " and activity with achievement",
    "hintOffset": 1472
  }
}
```

On load, the editor re-finds the anchor text using fuzzy matching. The Markdown file stays completely clean, but the agent must read and update both files to work with comments.

### Option C: End-of-File Comment Block

Collect all comments into a single HTML comment block at the bottom (or top) of the Markdown file, using content-based anchoring.

```markdown
---
title: Why Startups Fail
---

The real problem with most startups isn't that
founders confuse motion with progress.

<!-- @comments
c1: "tighten this, too wordy" | anchor: "founders confuse motion with progress"
c2: "add a concrete example" | anchor: "day-to-day operations"
-->
```

Comments are in the file (so agents see them) but collected in one place rather than scattered inline. Connection between instruction and text is indirect ‚Äî the agent must search for the quoted anchor text.

### Option D: Proprietary Format with Markdown Export

Use a custom file format (e.g., a structured file or archive containing the Markdown content plus a comment layer). The editor renders it natively, and clean Markdown is exported for publishing.

This gives full control over the comment model but means the file is no longer directly editable as plain Markdown. Agents can only interact with it through the editor's tooling.

---

## Trade-Off Matrix

| Criteria | A: Inline HTML | B: Sidecar File | C: End-of-File Block | D: Proprietary Format |
|---|---|---|---|---|
| **Markdown stays valid** | ‚úÖ Yes, HTML comments are spec-compliant | ‚úÖ Markdown is untouched | ‚úÖ Yes, HTML comments are spec-compliant | ‚ùå Not a `.md` file at all |
| **Clean raw view in other editors** | ‚ö†Ô∏è Markers visible in source view | ‚úÖ Completely clean | ‚ö†Ô∏è One comment block visible at end of file | ‚ùå Not openable in other editors |
| **Clean rendered output** | ‚úÖ HTML comments are hidden by renderers | ‚úÖ No comment artifacts | ‚úÖ HTML comments are hidden by renderers | ‚úÖ Export produces clean Markdown |
| **Character-level anchor precision** | ‚úÖ Exact range via markers (when marker placement is valid) | ‚ö†Ô∏è Depends on fuzzy matching quality | ‚ö†Ô∏è Depends on anchor quote uniqueness | ‚úÖ Full control over anchor model |
| **Agent can see instructions** | ‚úÖ Instructions inline next to relevant text | ‚ùå Must read separate file and cross-reference | ‚ö†Ô∏è Visible but separated from relevant text | ‚ùå Requires custom tooling |
| **Agent can edit without special tools** | ‚úÖ Plain text manipulation | ‚ö†Ô∏è Must update both files and maintain offsets | ‚úÖ Plain text manipulation | ‚ùå Must use editor API or MCP tool |
| **Survives external edits** | ‚ö†Ô∏è Often survives simple edits, but malformed/orphaned markers are possible | ‚ùå Offsets break; fuzzy matching may recover | ‚ö†Ô∏è Anchor quotes may no longer match after edits | ‚ùå External edits not possible |
| **Comment density scales** | ‚ö†Ô∏è Heavy commenting clutters the source | ‚úÖ No impact on source readability | ‚ö†Ô∏è Large comment block at end, but body stays clean | ‚úÖ Comments in separate layer |
| **Implementation complexity** | üü° Medium ‚Äî marker parsing/validation, malformed-marker recovery | üî¥ High ‚Äî fuzzy matching, offset tracking, two-file sync | üü° Medium ‚Äî parse comment block + anchor resolution | üî¥ High ‚Äî custom format, import/export pipeline |
| **Works for ephemeral task-style comments** | ‚úÖ Agent acts on it and deletes markers | ‚ö†Ô∏è Agent must clean up sidecar entries | ‚úÖ Agent resolves and removes entries from block | ‚úÖ Full control |

---

## UX Model (MVP)

The comment UX should mirror the interaction model users expect from tools like Notion and Google Docs while still storing anchors as inline Markdown HTML comments under the hood.

### Creating a Comment

1. The user selects text in the editor (highlighted selection).
2. The user right-clicks the selection and chooses **Create comment** from the context menu.
3. The app creates a new comment anchored to that selected range and opens a blank comment UI on the right side of the text.

### Editing and Displaying Comments

- Each comment highlight in the document has a corresponding floating comment box (bubble/text box) rendered to the right side of the text column.
- The floating comment box displays the comment contents and is directly editable in place.
- As the user types, the comment text updates in that floating box UI.
- Clicking any text within the highlighted comment range should select/focus the corresponding comment UI.

## Summary

For a Markdown-native editor where comments are temporary agent instructions, **Inline HTML Comments (Option A)** still offers the best balance of simplicity, agent ergonomics, and ecosystem compatibility. The main downside ‚Äî visible markers in raw source view ‚Äî is mitigated by the fact that these comments are ephemeral and expected to be resolved and removed.

For Kale's first pass specifically, we will use Option A with a deliberately permissive anchoring model (no extra character-selection restrictions yet), while enforcing **no nested comments**, **no overlapping comments**, and **generated unique IDs** per comment marker pair. This is an MVP tradeoff, not a claim that arbitrary marker placement is always safe in Markdown.

**End-of-File Block (Option C)** is the runner-up, trading positional precision for a cleaner editing experience in the document body. It's a good fallback if inline markers create too much noise during writing.

**Sidecar File (Option B)** keeps the Markdown pristine but creates significant friction for AI agents and breaks easily on external edits. Best suited for permanent annotations in read-heavy, write-light scenarios.

**Proprietary Format (Option D)** is the most powerful but abandons the core premise of Markdown-on-disk editability. Only justified if the editor becomes the sole interface for working with these files.
